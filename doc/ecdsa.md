# Prime Field

Given a odd prime p, the integers {0, 1, ..., p-1} form a finite field Fp.

Operations:

* Addition

```
a + b mod p
```

* Subtraction

```
a - b mod p
```

* Multiplication

```
a * b mod p
```

* Inversion

```
a^-1 mod p
```

# Elliptic Curve

An elliptic curve defined over a prime field Fp with the following equation:

    y^2 = x^3 + a*x + b

Basic parameters:

* p: the prime
* a
* b
* G: the base point
* n: order of the base point G

As for P-256, the parameters are:

```
p = 2^256 - 2^224 + 2^192 + 2^96 - 1
a = p-3
G: x = 0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296
   y = 0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5
n = 0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551
```

Curve point: P with coordinates (x, y)
Infinite point: O

**Note**: all the computations below are on field Fp.

## Double Point

**Input** point P1(x1, y1)

**Output** point P2(x2, y2) = [2]P1

If P1 is O, the result is O.

Else, process the following computation.

```
X1 = x1, Y1 = y1, Z1 = 1
S = 4 * X1 * Y1^2
M = 3 * X1^2 + a * Z1^4
X2 = M^2 - 2 * S
Y2 = M * (S - X2) - 8 * Y1^4
Z2 = 2 * Y1 * Z1
x2 = X2 / Z2^2
y2 = Y2 / Z2^3
return (x2, y2)
```


## Point Addition

**Input** two point P1(x1, y1) and P2(x2, y2).

**Output** point P3(x3, y3) = P1 + P2


If P1 is O, then P3 = P2.

If P2 is O, then P3 = P1.

Else, process the following computation.


```
X1 = x1, Y1 = y1, Z1 = 1
X2 = x2, Y2 = y2, Z2 = 1

U1 = X1 * Z2^2
U2 = X2 * Z1^2
S1 = Y1 * Z2^3
S2 = Y2 * Z1^3

if U1 == U2 && S1 != S2:
    return O
else if U1 == U2 && S1 == S2:
    return [2]P1
else:
    H = U2 - U1
    R = S2 - S1
    X3 = R^2 - H^3 - 2 * U1 * H^2
    Y3 = R * (U1 * H^2 - X3) - S1 * H^3
    Z3 = H * Z1 * Z2
    x3 = X3 / Z3^2
    y3 = Y3 / Z3^3
    return (x3, y3)
```


While [2]P is the double point of P, [k]P is the k times point of P. Calculation
of [k]P is the combination of Double Point and Point Addition, for example
[6]P = [2]([2]P + P).


# ECDSA Verification

**Input**

* Public key P(x, y), a point on the curve
* Signed data e, a byte sequence, usually the digest of the original message
  generated by a hash function
* Signature (r, s), a pair of integers in Fp.

**Output**

TRUE or FALSE

**Process**

1. Verify that r, s ∈ [1, n-1]. IF not, return FALSE.
2. w = s^-1 mod n
3. u1 = e*w mod n, u2 = r*w mod n
4. Q(x1, y1) = [u1]G + [u2]P. If Q is the infinite point, return FALSE.
5. If r ≡ x1 mod n, return TRUE. Else return FALSE.


# Optimizations

## Montgomery Multiplication

The prime field multiplication is the most time consuming operation and could
be optimized using Montgomery Multiplication (MM).

Assume `p` is a `l` bits prime, MM can efficiently calculate `a * b * 2^-l mod p`.

```
Input    p, a, b, l = s * k, where s is the unit length for calculation

Output   a * b * 2^-l mod p

Pre-compute k0 = -p^-1 mod 2^s

t = a * b
for i <- 1 to k:
    t1 = t mod 2^s
    u = t1 * k0 mod 2^s
    t2 = u * p
    t3 = t + t2
    t = t3 / 2^s

if t >= p: x = t - p
else: x = p

return x
```

Obviously, the only division operation can be done by bit shifts.

For calculating `a * b mod p`, first transform `a` and `b` to `a'` and `b'`:

```
a' = a * 2^l ≡ a * 2^2l * 2^-l mod p
b' = b * 2^l ≡ b * 2^2l * 2^-l mod p
```

Then calculate 

```
t = a' * b' * 2^-l mod p
a * b ≡ 1 * t * 2^-l mod p
```

Since, MM is complete for the whole calculation.


## The Double-Base Number System

TODO


# Further Reading

[1] nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf

[2] https://eprint.iacr.org/2013/816.pdf

[3] http://www.hackersdelight.org/MontgomeryMultiplication.pdf

[4] http://web.science.mq.edu.au/~doche/asilomar.pdf
